---
layout: post
title: Redis 性能优化指北
---
搜索业务一直是Redis使用的VIP客户, Redis的读写性能很大程度决定了搜索业务的响应状态. 本着扣一点是一点的优化精神, 搜索团队在Redis的使用中尝试了一些实测有效的优化方案, 分享给大家.

1. 高效序列化+压缩

搜索业务使用Redis的核心场景, 是缓存供应商传来的航班列表+报价数据. 供应商传来的数据, 往往是数百KB甚至MB级别的大JSON, 再乘上航班列表搜索每天近万条不同的航线请求, 数据可以轻松突破GB量级. 这么大的开销, Redis又不是只有们在用, 直接存储肯定不合适. 

搜索团队的解决方案, 就是在原始数据的体积上做文章. 我们对存入redis的数据会做两歩处理, 
2. 序列化, 将数据对象使用高性能序列化的方式变为二进制数据. 之前用JSON, 序列化后的体积很大, 后来我们调研了其他序列化方式, Kryo性能及体积都不错, 但是使用起来不是很简单. 目前看起来, protostuff是一个不错的选择, 兼顾了API的易用性, 序列化速度, 和序列化体积. 作为Google开源的项目, 后续维护也比较有保障.
3. 压缩, 使用protostuff会比JSON小接近50%, 但是仍然有进一步压缩的空间. 我们使用ZLIB工具对序列化后的二进制数据再次压缩, 得到压缩后的Byte数组.

经过上述工具的数据, 体积就已经很小了, 通过使用原始的RedisTemplate, 可以将二进制数据直接存入Redis. 从Redis读取时, 对读取到的字节数组进行解压缩和反序列化处理, 就可以得到Java对象.

1. 使用正确的存储结构

Redis提供了很多存储结构, 每个结构都有其最优的使用场景. 直接将KV对存入Redis很多时候是一种很浪费的做法.
Redis内部最基础的结构是字典结构. 而每写入一个Key, 都会增加一个DictEntry, 如下图所示, DictEntry实际上会占用不少内存.
![图片](https://uploader.shimo.im/f/tk8FgQa9bt8uFiUy.png!thumbnail)
而且, Redis在Key较多的情况下会对Dict进行Rehash和扩容, 会申请很多内存空间. 
事实上, 针对大量体积较小的数据, Redis有专门的存储结构, 即Hash. 在Hash结构中, 如果数据条数不多的话, Redis会将Hash存成双端链表的形式, 进而省去了存储字典的开销. 
所以, 如果需要存储少量体积不大的值, 可以考虑使用Hash结构. [分享一篇Hash结构的使用实践](https://searchdatabase.techtarget.com.cn/7-20255/).

Redis还有诸如Set, List等数据结构, 分别针对不同的使用场景, 大家也可以进一步研究.

4. 使用连接池

搜索业务曾经出现过一段Redis访问非常慢的情况. 最后发现Spring自带的Redis客户端Lettuce在默认情况下, 每次访问Redis都会新建Http链接. 众所周知Linux维护Http连接资源是有上限的, 而且每次连接释放是会有接近一分钟的Time_wait状态, 此时端口不可用. 
所以, 当业务需要频繁读写Redis时, 应该加上连接池配置. 这里提供fwl的连接池配置供参考.
```
spring.redis.lettuce.pool.min-idle=5
spring.redis.lettuce.pool.max-active=20
```

5. 使用命名空间

使用命名空间其实是一种最佳实践. 本质上可能并不会提高Redis的性能, 但是为人为查询Redis缓存信息提供了便利. 以Redis Desktop Manager为例, 相同命名空间下的Key会收起到一个目录中. 在Key较多的时候, 可以方便查找.


---
以上是对搜索团队使用Redis过程中优化经验进行的总结. 所述不一定全对, 但多少有些参考意义. 抛砖引玉, 希望大家可以更多的分享有关中间件服务的使用心得.